/*
 * generated by Xtext 2.12.0
 */
package org.xtext.miron.serializer;

import com.google.inject.Inject;
import java.util.Set;
import miron.metamodel.datatypes.BehaviorTreeLiteral;
import miron.metamodel.datatypes.MironModel;
import miron.metamodel.kernel.Binding;
import miron.metamodel.kernel.Import;
import miron.metamodel.kernel.KernelPackage;
import miron.metamodel.kernel.Rule;
import miron.metamodel.kernel.VariantAssignment;
import miron.metamodel.kernel.VariationPoint;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.miron.services.MIRoNGrammarAccess;
import org.xtext.roqme.serializer.RoQMESemanticSequencer;
import roqme.metamodel.datatypes.ArrayValue;
import roqme.metamodel.datatypes.BooleanType;
import roqme.metamodel.datatypes.BooleanValue;
import roqme.metamodel.datatypes.ContainedDeclaration;
import roqme.metamodel.datatypes.DataTypeDefinition;
import roqme.metamodel.datatypes.DatatypesPackage;
import roqme.metamodel.datatypes.EnumLiteral;
import roqme.metamodel.datatypes.EnumType;
import roqme.metamodel.datatypes.EnumValue;
import roqme.metamodel.datatypes.EventType;
import roqme.metamodel.datatypes.EventValue;
import roqme.metamodel.datatypes.InbuiltDeclaration;
import roqme.metamodel.datatypes.LowerBound;
import roqme.metamodel.datatypes.NumericType;
import roqme.metamodel.datatypes.NumericValue;
import roqme.metamodel.datatypes.ReferencedDeclaration;
import roqme.metamodel.datatypes.RoqmeModel;
import roqme.metamodel.datatypes.TimeType;
import roqme.metamodel.datatypes.TimeValue;
import roqme.metamodel.datatypes.UnitMeasuredType;
import roqme.metamodel.datatypes.UnitMeasuredValue;
import roqme.metamodel.datatypes.UpperBound;
import roqme.metamodel.expressions.AddTerm;
import roqme.metamodel.expressions.AggregationFunction;
import roqme.metamodel.expressions.AndBooleanTerm;
import roqme.metamodel.expressions.AndEventTerm;
import roqme.metamodel.expressions.ArithFunction;
import roqme.metamodel.expressions.CollectionFunction;
import roqme.metamodel.expressions.ConditionalTerm;
import roqme.metamodel.expressions.ConstTerm;
import roqme.metamodel.expressions.ContextPattern;
import roqme.metamodel.expressions.DivTerm;
import roqme.metamodel.expressions.EqualTerm;
import roqme.metamodel.expressions.ExpressionsPackage;
import roqme.metamodel.expressions.FollowedByTerm;
import roqme.metamodel.expressions.GeneralExpression;
import roqme.metamodel.expressions.GreaterEqualTerm;
import roqme.metamodel.expressions.GreaterThanTerm;
import roqme.metamodel.expressions.LessEqualTerm;
import roqme.metamodel.expressions.LessThanTerm;
import roqme.metamodel.expressions.MultTerm;
import roqme.metamodel.expressions.NotBooleanTerm;
import roqme.metamodel.expressions.NotEqualTerm;
import roqme.metamodel.expressions.NotEventTerm;
import roqme.metamodel.expressions.OnceTerm;
import roqme.metamodel.expressions.OrBooleanTerm;
import roqme.metamodel.expressions.OrEventTerm;
import roqme.metamodel.expressions.OutputTransformation;
import roqme.metamodel.expressions.PatternFunction;
import roqme.metamodel.expressions.RangeTerm;
import roqme.metamodel.expressions.RepeatTerm;
import roqme.metamodel.expressions.ScheduleFunction;
import roqme.metamodel.expressions.SelfTerm;
import roqme.metamodel.expressions.SubTerm;
import roqme.metamodel.expressions.VarTerm;
import roqme.metamodel.expressions.WhileTerm;
import roqme.metamodel.kernel.BeliefVariable;
import roqme.metamodel.kernel.ClearEvidence;
import roqme.metamodel.kernel.DerivedContext;
import roqme.metamodel.kernel.GeneralPurposeVariable;
import roqme.metamodel.kernel.Observation;
import roqme.metamodel.kernel.PrimitiveContext;
import roqme.metamodel.kernel.Property;
import roqme.metamodel.kernel.ResumeTimer;
import roqme.metamodel.kernel.SetEvidence;
import roqme.metamodel.kernel.SetVariable;
import roqme.metamodel.kernel.StartTimer;
import roqme.metamodel.kernel.StopTimer;
import roqme.metamodel.kernel.Timer;

@SuppressWarnings("all")
public class MIRoNSemanticSequencer extends RoQMESemanticSequencer {

	@Inject
	private MIRoNGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DatatypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatatypesPackage.ARRAY_VALUE:
				if (rule == grammarAccess.getBooleanArrayRule()) {
					sequence_BooleanArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedValueRule()
						|| rule == grammarAccess.getArrayValueRule()) {
					sequence_BooleanArray_EnumArray_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnumArrayRule()) {
					sequence_EnumArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArray_ImplRule()) {
					sequence_NumericArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArrayRule()) {
					sequence_NumericArray_Impl_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTimeArrayRule()) {
					sequence_TimeArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitMeasuredArrayRule()) {
					sequence_TimeArray_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnitMeasuredArray_ImplRule()) {
					sequence_UnitMeasuredArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else break;
			case DatatypesPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case DatatypesPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case DatatypesPackage.CONTAINED_DECLARATION:
				sequence_ContainedDeclaration(context, (ContainedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.DATA_TYPE_DEFINITION:
				sequence_DataTypeDefinition(context, (DataTypeDefinition) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_TYPE:
				sequence_EnumType(context, (EnumType) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_TYPE:
				sequence_EventType(context, (EventType) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_VALUE:
				sequence_EventValue(context, (EventValue) semanticObject); 
				return; 
			case DatatypesPackage.INBUILT_DECLARATION:
				sequence_InbuiltDeclaration(context, (InbuiltDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.LOWER_BOUND:
				sequence_LowerBound(context, (LowerBound) semanticObject); 
				return; 
			case DatatypesPackage.NUMERIC_TYPE:
				sequence_NumericType(context, (NumericType) semanticObject); 
				return; 
			case DatatypesPackage.NUMERIC_VALUE:
				sequence_NumericValue_Impl(context, (NumericValue) semanticObject); 
				return; 
			case DatatypesPackage.REFERENCED_DECLARATION:
				sequence_ReferencedDeclaration(context, (ReferencedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.ROQME_MODEL:
				sequence_RoqmeModel(context, (RoqmeModel) semanticObject); 
				return; 
			case DatatypesPackage.TIME_TYPE:
				sequence_TimeType(context, (TimeType) semanticObject); 
				return; 
			case DatatypesPackage.TIME_VALUE:
				sequence_TimeValue(context, (TimeValue) semanticObject); 
				return; 
			case DatatypesPackage.UNIT_MEASURED_TYPE:
				sequence_UnitMeasuredType(context, (UnitMeasuredType) semanticObject); 
				return; 
			case DatatypesPackage.UNIT_MEASURED_VALUE:
				sequence_UnitMeasuredValue_Impl(context, (UnitMeasuredValue) semanticObject); 
				return; 
			case DatatypesPackage.UPPER_BOUND:
				sequence_UpperBound(context, (UpperBound) semanticObject); 
				return; 
			}
		else if (epackage == miron.metamodel.datatypes.DatatypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case miron.metamodel.datatypes.DatatypesPackage.BEHAVIOR_TREE_LITERAL:
				sequence_BehaviorTreeLiteral(context, (BehaviorTreeLiteral) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.MIRON_MODEL:
				sequence_MironModel(context, (MironModel) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ADD_TERM:
				sequence_AdditionTerm(context, (AddTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AGGREGATION_FUNCTION:
				sequence_AggregationFunction(context, (AggregationFunction) semanticObject); 
				return; 
			case ExpressionsPackage.AND_BOOLEAN_TERM:
				sequence_AndBooleanTerm(context, (AndBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AND_EVENT_TERM:
				sequence_AndEventTerm(context, (AndEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ARITH_FUNCTION:
				sequence_ArithFunction(context, (ArithFunction) semanticObject); 
				return; 
			case ExpressionsPackage.COLLECTION_FUNCTION:
				sequence_CollectionFunction(context, (CollectionFunction) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONST_TERM:
				sequence_ConstTerm(context, (ConstTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONTEXT_PATTERN:
				sequence_ContextPattern(context, (ContextPattern) semanticObject); 
				return; 
			case ExpressionsPackage.DIV_TERM:
				sequence_MultiplicationTerm(context, (DivTerm) semanticObject); 
				return; 
			case ExpressionsPackage.EQUAL_TERM:
				sequence_RelationalTerm(context, (EqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.FOLLOWED_BY_TERM:
				sequence_SequenceTerm(context, (FollowedByTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GENERAL_EXPRESSION:
				sequence_GeneralExpression(context, (GeneralExpression) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_EQUAL_TERM:
				sequence_RelationalTerm(context, (GreaterEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_THAN_TERM:
				sequence_RelationalTerm(context, (GreaterThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_EQUAL_TERM:
				sequence_RelationalTerm(context, (LessEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_THAN_TERM:
				sequence_RelationalTerm(context, (LessThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.MULT_TERM:
				sequence_MultiplicationTerm(context, (MultTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_BOOLEAN_TERM:
				sequence_NotBooleanTerm(context, (NotBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EQUAL_TERM:
				sequence_RelationalTerm(context, (NotEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EVENT_TERM:
				sequence_NotEventTerm(context, (NotEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ONCE_TERM:
				sequence_OnceTerm(context, (OnceTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_BOOLEAN_TERM:
				sequence_OrBooleanTerm(context, (OrBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_EVENT_TERM:
				sequence_OrEventTerm(context, (OrEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OUTPUT_TRANSFORMATION:
				sequence_OutputTransformation(context, (OutputTransformation) semanticObject); 
				return; 
			case ExpressionsPackage.PATTERN_FUNCTION:
				sequence_PatternFunction(context, (PatternFunction) semanticObject); 
				return; 
			case ExpressionsPackage.RANGE_TERM:
				sequence_RepetionTerm(context, (RangeTerm) semanticObject); 
				return; 
			case ExpressionsPackage.REPEAT_TERM:
				sequence_RepetionTerm(context, (RepeatTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SCHEDULE_FUNCTION:
				sequence_ScheduleFunction(context, (ScheduleFunction) semanticObject); 
				return; 
			case ExpressionsPackage.SELF_TERM:
				sequence_SelfTerm(context, (SelfTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SUB_TERM:
				sequence_AdditionTerm(context, (SubTerm) semanticObject); 
				return; 
			case ExpressionsPackage.VAR_TERM:
				sequence_VarTerm(context, (VarTerm) semanticObject); 
				return; 
			case ExpressionsPackage.WHILE_TERM:
				sequence_WhileTerm(context, (WhileTerm) semanticObject); 
				return; 
			}
		else if (epackage == KernelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case KernelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KernelPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case KernelPackage.VARIANT_ASSIGNMENT:
				sequence_VariantAssignment(context, (VariantAssignment) semanticObject); 
				return; 
			case KernelPackage.VARIATION_POINT:
				sequence_VariationPoint(context, (VariationPoint) semanticObject); 
				return; 
			}
		else if (epackage == roqme.metamodel.kernel.KernelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case roqme.metamodel.kernel.KernelPackage.BELIEF_VARIABLE:
				sequence_BeliefVariableImpl(context, (BeliefVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.CLEAR_EVIDENCE:
				sequence_ClearEvidence(context, (ClearEvidence) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.DERIVED_CONTEXT:
				sequence_DerivedContext(context, (DerivedContext) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.GENERAL_PURPOSE_VARIABLE:
				sequence_GeneralPurposeVariable(context, (GeneralPurposeVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.OBSERVATION:
				sequence_Observation(context, (Observation) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PARAMETER:
				sequence_Parameter(context, (roqme.metamodel.kernel.Parameter) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PRIMITIVE_CONTEXT:
				sequence_PrimitiveContext(context, (PrimitiveContext) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.RESUME_TIMER:
				sequence_ResumeTimer(context, (ResumeTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.SET_EVIDENCE:
				sequence_SetEvidence(context, (SetEvidence) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.SET_VARIABLE:
				sequence_SetVariable(context, (SetVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.START_TIMER:
				sequence_StartTimer(context, (StartTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.STOP_TIMER:
				sequence_StopTimer(context, (StopTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EnumLiteralAux returns BehaviorTreeLiteral
	 *     BehaviorTreeLiteral returns BehaviorTreeLiteral
	 *
	 * Constraint:
	 *     (name=ID reference=[BehaviorTree|EString])
	 */
	protected void sequence_BehaviorTreeLiteral(ISerializationContext context, BehaviorTreeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.ENUM_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.ENUM_LITERAL__NAME));
			if (transientValues.isValueTransient(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.BEHAVIOR_TREE_LITERAL__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.BEHAVIOR_TREE_LITERAL__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBehaviorTreeLiteralAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBehaviorTreeLiteralAccess().getReferenceBehaviorTreeEStringParserRuleCall_3_0_1(), semanticObject.eGet(miron.metamodel.datatypes.DatatypesPackage.Literals.BEHAVIOR_TREE_LITERAL__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (insertionType=InsertionTypeEnum (xpath=EString | (targets+=[EObject|EString] targets+=[EObject|EString]*)))
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumType returns EnumType
	 *     DataType returns EnumType
	 *
	 * Constraint:
	 *     (cardinality=INT? literals+=EnumLiteralAux literals+=EnumLiteralAux*)
	 */
	protected void sequence_EnumType(ISerializationContext context, EnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importURI=EString alias=EString?)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MironModel returns MironModel
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ((description=ElementDescription? namespace=EString sentences+=Import+) | sentences+=Import+)? 
	 *             (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *         ) | 
	 *         (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *     )?
	 */
	protected void sequence_MironModel(ISerializationContext context, MironModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Rule
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID trigger=ContextPattern (actions+=RuleAction | (actions+=RuleAction actions+=RuleAction+)))
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RuleAction returns VariantAssignment
	 *     VariantAssignment returns VariantAssignment
	 *
	 * Constraint:
	 *     (variable=[VariationPoint|QualifiedName] value=TypedValue)
	 */
	protected void sequence_VariantAssignment(ISerializationContext context, VariantAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.VARIANT_ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.VARIANT_ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.VARIANT_ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.VARIANT_ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariantAssignmentAccess().getVariableVariationPointQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(KernelPackage.Literals.VARIANT_ASSIGNMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getVariantAssignmentAccess().getValueTypedValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns VariationPoint
	 *     VariationPoint returns VariationPoint
	 *
	 * Constraint:
	 *     (name=ID declaration=DataTypeDeclaration binding=Binding)
	 */
	protected void sequence_VariationPoint(ISerializationContext context, VariationPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatatypesPackage.Literals.TYPED_VARIABLE__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.VARIATION_POINT__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.VARIATION_POINT__BINDING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariationPointAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariationPointAccess().getDeclarationDataTypeDeclarationParserRuleCall_3_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getVariationPointAccess().getBindingBindingParserRuleCall_4_0(), semanticObject.getBinding());
		feeder.finish();
	}
	
	
}
